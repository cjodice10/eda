---
title: "eda"
author: "Christopher Jodice"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# This Vignette is still in progress

## Why eda?
I created this package to help analyst have an easier way of conducting their exploratory data analysis (`eda`) when using R. Historically I've used other products which have really good, some-what automated, EDA tools in their software, but unfortunately these products can be real expensive.  So I wanted to create a package that can help others and ease their `eda` process using R.  My goal is that this `eda` package will give the analyst a tool to better understand their data and can easily represent some of the outputs to their clients.

This package, as of now, mainly focuses on data sets where the analyst is either modeling a binary response, or a response that reflects count data (I allow the user to give an exposure variable as well if they are using count data).  This package will explore each attribute in the data by binning and grouping records based on user inputs and the dependent variable (DV).  For example, it may be that the user wants to force monotonic binning on numeric variables, this package will allow this.  

Why bin variables though?  Well, depending on your analysis, binning does have it's benefits and at the same time has draw-backs.  The biggest draw-back is that when we bin variables to use in models, we naturally lose information, or lose the variability to be explained within the records of the bin.  But binning also has benefits.  It handles outliers very well, handles missing very well, and more.  

Here are the steps we will take using this `eda` package

- Import the data
- Summarize the data
- Split into development and holdout samples
- Conduct our EDA and understand relationships
- Apply transformations learned from the EDA
- Items to consider

After binning records together based on user specifications, we then transform the attribute to get a 'weight of evidence' (WOE) for each grouping.  This allows us to calculate how predictive an attribute might be by calculating it's information value (IV).  Because we calculate WOE, each variable can be transformed to a WOE value making all variables numeric - to include all missing values!.  This gives analyst some nice paths to move forward on.  When all variables can be translated to a numeric value, one can then take their analysis a step further and cluster variables together.  This can help an analyst to understand how each variable correlates to others. 

### Note
- Although examples of using variable clustering & selection are not part of this version, I do plan on adding this in future versions.

- WOE variables are built such that as the WOE value goes up, the event rate goes down.  Therefore, if an analyst is using the transformed WOE variables in their statistical modeling, they should expect negative signs in their parameter estimates.  

## Full disclosure
The data set I am using was created by myself and is fitted on an equation.  So as you can imagine, the data is in good shape - which in almost all projects is unlikely.  In fact, if you plot the raw covariates vs the DV, you will likely get really nice curves.  But for the sake of the demonstration on how to use this package, I will stick with this data set.  

Let's begin

## Import the data
Let's first begin by bringing in a fake data set called `df_example` that comes with this package
We'll also be using `dplyr` so we'll bring in that library

```{r, echo=TRUE}
#bring in the package
library(eda)

#bring in dplyr
library(dplyr,warn.conflicts = FALSE)

#bring in the example dataframe
data("df_example",package="eda")

#look at the structure
str(df_example)

```

We see that this datframe `df_example` has 50,000 observations and 8 variables.

- two categorical variables
- 6 numeric or int variables

Our dependent variable is called `target` and it is a binary response.

## Summarize the data
Our first step is to get a summary of distributions for this data set.  We can easily do that with this package.  We will use the function `get_percentile()` for a summary on numeric variables and `get_frequency()` for a summary on non-numeric variables.  Let's first start with `get_percentile()`  We will pass the data frame and numeric column names to it

```{r, echo=TRUE, results='asis'}
#get a list of numeric variable names
num_vars = names(df_example %>% dplyr::select_if(is.numeric))

#numeric summary
num_summary = get_percentile( df   = df_example
                             ,vars = num_vars)

#show the table
knitr::kable(num_summary)

```

You will get in return a dataframe with a percentile distribution a long with other data like:

- Percent Missing (PctMissing)
- Number of unique values (UniqueValues)
- Number of values less than 0 (LT0)
- Number of values equal to 0 (ET0)
- Number of values greather than 0 (GT0)

You'll also get the percentile distribution of all numeric variables along with the mean and stdev.

- You'll notice the event rate is about 18.4% for this data set

You can see here that the 'ID' variable uniquely identifies each row.  It has 50K unique values.  We will be using this throughout.

Next, let's take a look at `get_frequency()`  We will pass the data frame and non-numeric column names to it.  We will also pass 1 more parameter `unique.threshold.pct`  This tells the function to only calculate and output the frequency distribution of variables with less than this percent of unique values.  Imagine having 10,000 unique levels...this may take long to compute and also not easy to visually look at.  The function will return a list of two dataframes:

- index 1 will hold a dataframe of the frequency distribution for each variable
- index 2 will hold a dataframe that gives information about the number of unique levels and missing rates

```{r, echo=TRUE}
`%ni%` = Negate(`%in%`)

#get a list of numeric variable names
cat_vars = df_example[,colnames(df_example) %ni% num_vars] %>% colnames()

#numeric summary
cat_summary = get_frequency( df                   = df_example
                            ,vars                 = cat_vars
                            ,unique.threshold.pct = 0.8)

#take a look at the structure
str(cat_summary)

#extract dataframe from first index
cat_summary_frequencies = cat_summary[[1]]

#look at the first few records of index 1
knitr::kable(cat_summary_frequencies[1:10,])

```

Let's also look at the dataframe stored in the second index of `cat_summary`

```{r, echo=TRUE}
#extract dataframe
cat_summary_missing_rates = cat_summary[[2]]

#look at the first few records of index 1
knitr::kable(cat_summary_missing_rates)

```

This dataframe can be combined with the `num_summary` output to get a complete view of all variables and their unique values and missing rates.

```{r, echo=TRUE}
#combine
var_summary = bind_rows(num_summary[,1:5],cat_summary_missing_rates)

#look at the first few records of index 1
knitr::kable(var_summary)

```

## Split into development and holdout samples

For our next step, let's quickly split the data by taking a random 70/30 random sample for a development and a holdout sample

```{r, echo=TRUE}
#sample size
sample_size = floor(0.70 * nrow(df_example))

#for reproducibility
set.seed(1234)
dev_ind = sample(seq_len(nrow(df_example)), size = sample_size)

df_example_dev      = df_example[dev_ind, ]
df_example_holdout  = df_example[-dev_ind, ]
```

The analyst should also re-run the functions we went over above on the development sample to ensure things look OK. But we will move forward

## Conduct our EDA and understand relationships

Let's push the data through the `process_pipeline()` function.  We are expecting this to return several pieces of information in a list.  A lot of the defaults are already set.  To make this run correctly, ensure that your dependent variable (DV) is not categorical.  Our DV is called `target` and we set the `dv_type` to 'Binary' because we are predicting a binary response.  This eda package only works for when the DV represents a binary input (1/0) or a count (frequency)

```{r, echo=TRUE}

#begin binning
my_eda = process_pipeline( run_id           = 'MyRun1'
                          ,df               = df_example_dev
                          ,unique_id_var    = "id"
                          ,dv_var           = "target"
                          ,dv_type          = "Binary"
                          ,var_list         = c("x1","x2","x3","x4","cat_var1","cat_var2")
                          ,num_nbins        = 20
                          ,num_min_pct      = 0.05
                          ,num_monotonic    = FALSE
                          ,cat_min_pct      = 0.05
                          ,eda_tracking     = TRUE
                          ,path_2_save      = "/Users/jodicefamily/Rprojects/Testing"
)

#let's look at the names
names(my_eda)

#you can also look at the structure if needed - but we will review below
#str(my_eda)

```

First you'll notice that as the algorithm is processing, it gives you some tracking information.  It tells you which variable it is at along with what it is doing.  Example `Looping through because minimum percent threshold is not met...`.  This information is output because our `eda_tracking` parameter is set to TRUE.  If we set it to FALSE, this information will not show.

The notes also tell us where some files are saved that may be useful for the user to export and possibly send to their clients, bring those tables into a PPT, or just to have on file.  

Another interesting feature for this `eda` package is that it creates a file(s) within the `path_2_save` suffixed with `*_log_file.txt`.  It tracks when bins are being merged so the user can see reasons why.  This file creation may need more work, but it is a start.  I want to give the user transparency into why the algorithm is deciding to merge bins together.  These files will be created only if `eda_tracking` is set to TRUE.

The output has produced several tables with quite a bit of information.  Let's first see the table it produced called `Numeric_eda` - but subset it to where `Variable` == 'x4'.

```{r, echo=TRUE}
num_eda = my_eda$Numeric_eda

#look at variable x1
num_eda_subset = num_eda[which(num_eda$Variable=="x1"),]
knitr::kable(num_eda_subset,row.names = FALSE)

```

If one wanted to, this table can be used to create graphs to show the relationship with each variable and the DV.  It's a nice way of easily displaying the data.  Below, we'll easily display the relationship with the new variable and the percent of records in each bin (or grouping)

```{r, echo=TRUE, fig.show='hold'}
library(ggplot2)

#now plot the event rate
ggplot(num_eda_subset,aes(x=bin_id,y=EventRate)) +
  geom_bar(stat="identity",color="azure", fill="aquamarine3")+
  scale_x_discrete(name ="bin_id", 
                    limits= sort(num_eda_subset$bin_id))+
  theme_bw()+
  labs(title="Event Rate of Variable: x1")

#now plot the percent records
ggplot(num_eda_subset,aes(x=bin_id,y=PctRecords)) +
  geom_bar(stat="identity",color="white", fill="steelblue")+
  scale_x_discrete(name ="bin_id", 
                    limits= sort(num_eda_subset$bin_id))+
  theme_bw()+
  labs(title="% of Records in each bin_id")

```

### Variable ranking
We can rank variables and their predictive power by looking at their information values (IV).  This can be extracted from the output of the `process_pipeline()` we recently ran and assigned it to `my_eda`.  The names are called:

- numeric_iv
- categorical_iv

Let's combine them together and then plot it to get a good view

```{r, echo=TRUE, fig.show='hold'}
ivs = bind_rows(my_eda$numeric_iv,my_eda$categorical_iv) %>% arrange(desc(IV)) %>% data.frame()

#now plot the event rate
ivs %>%
  arrange(desc(IV)) %>%
  mutate(Variable=factor(Variable, levels=Variable)) %>%
  ggplot(aes(x=Variable,y=IV)) +
  geom_bar(stat="identity",color="azure", fill="aquamarine3")+
  theme_bw()+
  labs(title="Variable Ranking using IV's")

```

Above, we see that the variable 'x4' has the highest predictive power with a very large IV ... IV's fairly large like this would be considered 'suspicous' but that is a topic we won't dive into here.  We will keep moving forward for demonstration purposes.

Using this, an analyst can set a minimum threshold on the IV to begin to remove variables if needed.  This still leaves the case of collinearity amongst other attributes, but again we won't be discussing that here.

### Variable logic for new data set

We also see as an output table suffixed by `*_logics`.  This is used to apply these transformations to your train data, test data and if used in production.  User can either apply `woe` logic, `grp` logic or both.  `grp` logic is just transforming the original variables to a 'group'.  If the analyst applies the `grp` logic to a data set and builds a model, they should use these transformed GRP attributes as categorical, not numeric in the model.  Let's take a look at some of these logics


```{r, echo=TRUE}
numeric_logics = my_eda$numeric_logics

#look at variable x1
numeric_logics_subset = numeric_logics[which(numeric_logics$Variable=="x1"),]
knitr::kable(numeric_logics_subset,row.names = FALSE)

```

```{r, echo=TRUE}
cat_logics = my_eda$categorical_logics

#look at variable x1
cat_logics_subset = cat_logics[which(cat_logics$Variable=="cat_var2"),]
knitr::kable(cat_logics_subset,row.names = FALSE)

```


## Apply transformations learned from the EDA

To apply these transformation to the development, holdout and more data sets, we can simply use the `apply_numeric_logic()` function. Let's go ahead an apply the transformations so we can see how.  We will pass into the function the dataset we want to transform `main_df`, the numeric logic, a unique id variable and the transformations we want (either `woe` or `grp` or both).  In this case we will use `woe

```{r, echo=TRUE}

numeric_logics = my_eda$numeric_logics

num_transformed_df = apply_numeric_logic( main_df       = df_example_dev
                                          ,logic_df      = numeric_logics
                                          ,unique_key_id = "id"
                                          ,logic_type    = "woe") #c("woe","grp")

#look at a summary
summary(num_transformed_df)
```

## Items to consider

- If the analyst is forcing monotonic binning on numeric attributes, you may get an information value that is really low if the attribute truely has a non-monotonic relationship with the DV.  Picture a U-shaped relationship.  A linear correlation on a U-shaped relationship will be near 0.  
- At this point, the algorithm cannot run both monotonic==TRUE and FALSE in the same run.  If the analyst wants to check both, it will have to be two separate runs (use the `run_id` parameter to specify differnt runs)
- For categorical data with text as inputs.  I would remove any comma's, quotation marks and escape characters before using this package.
- Setting the initial `num_nbins` to something large (say 200 or 300) with `num_monotonic` = TRUE and a high `num_min_pct` may be innefficient.  
- When applying the logics to a new data set and there are values within categorical fields that are new (were not in the development sample), it will be missing.  User needs to apply their own transformation.  Some guidance - if user is using `woe` transformations, then consider giving those records a woe_<variable> value of 0.  If user is using `grp` transformation, then consider giving those records a grp_<variable> value that reflects the average event rate...user has to manually see for each variable, which is the downside for unforeseen values when using `grp`.  Similarly for numeric attributes.  This will happen to numeric attributes only for missing values.  If there are no missing values in the development sample but there are in other data sets, user can follow similar guidance above.



